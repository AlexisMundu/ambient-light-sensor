///////////////////////////////////////////////////////////////////////////////
// Description: Top level file for Ambient Light Sensor project on Go Board.
//
//              Interfaces to Digilent PMOD ALS (Ambient Light Sensor).
//              Uses SPI to receive 3 bytes from PMOD board.
//              SPI operates at 2.5 MHz, CPHA = 1, CPOL = 1.
//              Format of data coming back from board is:
//                      MSB                          LSB 
//      Index   7  6  5  4  3  2  1  0  |  7  6  5  4  3  2  1  0  |
//      Data    0  0  0  D7 D6 D5 D4 D3    D2 D2 D0 0  0  0  0  Z     
//
///////////////////////////////////////////////////////////////////////////////

module Light_Sensor_ALS
  (
   // Control/Data Signals,
   input  i_Rst_L, // FPGA Reset
   input  i_Clk, // FPGA Clock

   // LED interface
   output o_LED_1,
   output o_LED_2,
   output o_LED_3,
   output o_LED_4,

   // UART TX for testing
   output o_UART_TX,
   
   // PMOD SPI Interface
   output o_SPI_Clk,
   input  i_SPI_MISO,
   output o_SPI_MOSI,
   output o_SPI_CS
   );


   // CPOL = 1 and CPHA = 1, based on ADC part ADC08S021
   localparam SPI_MODE = 3;

   // Go Board operates at 25 MHz, so divide by 10 to get to 2.5 MHz.
   // This is clocks per half bit, so divide 10 by 2 to get 5. 
   localparam CLKS_PER_HALF_BIT = 5;
   

   reg [7:0] r_LED_Count; 
   wire [7:0] w_Ambient_Val;
   reg [15:0] r_ADC_Word;
   reg r_MSB_Active;
      
   
  // Instantiate Master to talk to Light Sensor
  SPI_Master 
    #(.SPI_MODE(SPI_MODE),
      .CLKS_PER_HALF_BIT(CLKS_PER_HALF_BIT)
      ) SPI_Master_Inst
  (
   // Control/Data Signals,
   .i_Rst_L(i_Rst_L),     // FPGA Reset
   .i_Clk(i_Clk),         // FPGA Clock
   
   // TX (MOSI) Signals
   .i_TX_Byte(8'h00),                // Hardcode data to zero, unused
   .i_TX_DV(r_ADC_Sample),           // Data Valid Pulse with i_TX_Byte
   .o_TX_Ready(w_SPI_Ready),         // Transmit Ready for Byte
   
   // RX (MISO) Signals
   .o_RX_DV(w_SPI_RX_DV),       // Data Valid pulse (1 clock cycle)
   .o_RX_Byte(w_SPI_RX_Byte),   // Byte received on MISO

   // SPI Interface
   .o_SPI_Clk(o_SPI_Clk),
   .i_SPI_MISO(i_SPI_MISO),
   .o_SPI_MOSI(o_SPI_MOSI)
   );


  // Purpose: Handle CS generation, data requesting.
  // Read from the light sensor at a 1 KHz rate.
  // Requests 2 bytes at a time.
  // Simple state machine is used here.
  always @(posedge i_Clk)
    begin
       r_SM_Main <=  
    end
   
  

   // Purpose: Handle data being read back from SPI
   // Pack up response into a single 8-bit value for ambient light.
  always @(posedge i_Clk)
    begin
      if (r_SPI_CS == 1'b0)
	begin
	  r_MSB_Active <= 1'b1; 
        end
      else if (w_SPI_RX_DV == 1'b1 && r_MSB_Active == 1'b1)
	begin
	  r_MSB_Active     <= 1'b0;
	  r_ADC_Word[15:8] <= w_SPI_RX_Byte;	   
	end
      else if (w_SPI_RX_DV == 1'b1 && r_MSB_Active == 1'b0)
	begin
	  r_MSB_Active    <= 1'b1;
	  r_ADC_Word[7:0] <= w_SPI_RX_Byte;
	end
    end

  // Drop first 3 bits and last 5 
  assign w_Ambient_Val = r_ADC_Word[12:5];
   
  // Based on the value read back from the ADC, modify the LED brightness
  // 0 is off, 255 is max brightness.  Achieved by driving duty cycle.
  always @(posedge i_Clk)
    begin
      r_LED_Count  <= r_LED_Count + 1;
      r_LED_Enable <= (r_LED_Count < w_Ambient_Val);
    end

   // Should assign all 4 here, but use 2 as brightness reference for now.
   assign o_LED_1 = 1'b1;
   assign o_LED_2 = 1'b0;
   assign o_LED_3 = r_LED_Enable;
   assign o_LED_4 = r_LED_Enable;

endmodule // Light_Sensor_ALS

